//`timescale 20 ns / 0.01 ns
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
/////////////////////////////**************************************////////////////////////////////
/////////////////////////////****************************************//////////////////////////////
//******  Top level file adapted from the Adaptive filtering project by Saurabh & Jesse, CSU**/////
//*********  Modified by: Saurabh Gupta & William Hudson, Wilson Lab, CSU 			*********///// 
//////////////////////////////****************************************////////////////////////////

module DE2115_EightLockins_top(

	//////////// CLOCK //////////
	CLOCK_50,
	CLOCK2_50,
	CLOCK3_50,

	//////////// LED //////////
	LEDG,
	LEDR,

	//////////// KEY //////////
	KEY,

	//////////// SW //////////
	SW,

	//////////// SEG7 //////////
	HEX0,
	HEX1,
	HEX2,
	HEX3,
	HEX4,
	HEX5,
	HEX6,
	HEX7,

	//////////// LCD //////////
	LCD_BLON,
	LCD_DATA,
	LCD_EN,
	LCD_ON,
	LCD_RS,
	LCD_RW,
	
		//////// GPIO //////////
	GPIO,

	//////////// SDCARD //////////
	SD_CLK,
	SD_CMD,
	SD_DAT,
	SD_WP_N,

	//////////// I2C for HSMC  //////////
	I2C_SCLK,
	I2C_SDAT,

	//////////// Flash //////////
	FL_ADDR,
	FL_CE_N,
	FL_DQ,
	FL_OE_N,
	FL_RST_N,
	FL_RY,
	FL_WE_N,
	FL_WP_N,
	
	//////////// SRAM //////////
	SRAM_ADDR,
	SRAM_CE_N,
	SRAM_DQ,
	SRAM_LB_N,
	SRAM_OE_N,
	SRAM_UB_N,
	SRAM_WE_N,		

	//////////// HSMC, HSMC connect to DCC - High Speed ADC/DAC //////////
	AD_SCLK,
	AD_SDIO,
	ADA_D,
	ADA_DCO,
	ADA_OE,
	ADA_OR,
	ADA_SPI_CS,
	ADB_D,
	ADB_DCO,
	ADB_OE,
	ADB_OR,
	ADB_SPI_CS,
	AIC_BCLK,
	AIC_DIN,
	AIC_DOUT,
	AIC_LRCIN,
	AIC_LRCOUT,
	AIC_SPI_CS,
	AIC_XCLK,
	CLKIN1,
	CLKOUT0,
	DA,
	DB,
	FPGA_CLK_A_N,
	FPGA_CLK_A_P,
	FPGA_CLK_B_N,
	FPGA_CLK_B_P,
	J1_152,
	XT_IN_N,
	XT_IN_P
);

//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;
input 		          		CLOCK2_50;
input 		          		CLOCK3_50;

//////////// LED //////////
output		     [8:0]		LEDG;
output		    [17:0]		LEDR;

//////////// KEY //////////
input 		     [3:0]		KEY;

//////////// SW //////////
input 		    [17:0]		SW;

//////////// SEG7 //////////
output		     [6:0]		HEX0;
output		     [6:0]		HEX1;
output		     [6:0]		HEX2;
output		     [6:0]		HEX3;
output		     [6:0]		HEX4;
output		     [6:0]		HEX5;
output		     [6:0]		HEX6;
output		     [6:0]		HEX7;

//////////// LCD //////////
output		          		LCD_BLON;
inout 		     [7:0]		LCD_DATA;
output		          		LCD_EN;
output		          		LCD_ON;
output		          		LCD_RS;
output		          		LCD_RW;

//////////// SDCARD //////////
output		          		SD_CLK;
inout 		          		SD_CMD;
inout 		     [3:0]		SD_DAT;
input 		          		SD_WP_N;

//////////// GPIO //////////
inout		        [35:0]		GPIO;

//////////// SRAM //////////
output		    [19:0]		SRAM_ADDR;
output		          		SRAM_CE_N;
inout 		    [15:0]		SRAM_DQ;
output		          		SRAM_LB_N;
output		          		SRAM_OE_N;
output		          		SRAM_UB_N;
output		          		SRAM_WE_N;

//////////// I2C for HSMC  //////////
output		          		I2C_SCLK;
inout 		          		I2C_SDAT;

//////////// Flash //////////
output		    [22:0]		FL_ADDR;
output		          		FL_CE_N;
inout 		     [7:0]		FL_DQ;
output		          		FL_OE_N;
output		          		FL_RST_N;
input 		          		FL_RY;
output		          		FL_WE_N;
output		          		FL_WP_N;

//////////// HSMC, HSMC connect to DCC - High Speed ADC/DAC //////////
inout 		          		AD_SCLK;
inout 		          		AD_SDIO;
input 		    [13:0]		ADA_D;
input 		          		ADA_DCO;
output		          		ADA_OE;
input 		          		ADA_OR;
output		          		ADA_SPI_CS;
input 		    [13:0]		ADB_D;
input 		          		ADB_DCO;
output		          		ADB_OE;
input 		          		ADB_OR;
output		          		ADB_SPI_CS;
inout 		          		AIC_BCLK;
output		          		AIC_DIN;
input 		          		AIC_DOUT;
inout 		          		AIC_LRCIN;
inout 		          		AIC_LRCOUT;
output		          		AIC_SPI_CS;
output		          		AIC_XCLK;
input 		          		CLKIN1;
output		          		CLKOUT0;
output		    [13:0]		DA;
output		    [13:0]		DB;
inout 		          		FPGA_CLK_A_N;
inout 		          		FPGA_CLK_A_P;
inout 		          		FPGA_CLK_B_N;
inout 		          		FPGA_CLK_B_P;
inout 		          		J1_152;
input 		          		XT_IN_N;
input 		          		XT_IN_P;

//=======================================================
//  REG/WIRE declarations
//=======================================================

wire					reset_n;
wire					sys_clk;
reg		[13:0]	per_a2da_d;
reg		[13:0]	a2da_data;
//reg			[13:0]	per_a2db_d;
//reg			[13:0]	a2db_data;
reg 		[13:0]  dac_out_a;
reg		[13:0]  dac_out_b; 
reg 		[13:0]  dac_out_a_unsigned;
reg		[13:0]  dac_out_b_unsigned;

	
reg l_CLOCK_50;
reg ll_CLOCK_50;
reg lll_CLOCK_50;

//=======================================================
//  Structural coding
//=======================================================

//--- global signal assign
assign	reset_n			= KEY[3];
assign   sys_clk = CLOCK_50;
assign	FPGA_CLK_A_P	=  ~CLOCK_50;
assign	FPGA_CLK_A_N	=  CLOCK_50;
assign	FPGA_CLK_B_P	=  ~CLOCK_50;
assign	FPGA_CLK_B_N	=  CLOCK_50;

assign	LEDG[1]			=	1'b0;
assign	LEDG[2]			=	1'b0;
assign	LEDG[3]			=  ADA_OR;
assign	LEDG[4]			=  ADB_OR;

assign 	LEDG[8:5]		=  4'b0;
assign 	LEDR[17:1]		=  17'b0;


assign	HEX0[6:0]		=	7'b1111111;
assign 	HEX1[6:0]		=	7'b1111111;
assign	HEX2[6:0]		=	7'b1111111;
assign	HEX3[6:0]		=	7'b1111111;
assign	HEX4[6:0]		=	7'b1111111;
assign	HEX5[6:0]		=	7'b1111111;
assign	HEX6[6:0]		=	7'b1111111;
assign 	HEX7[6:0]		=	7'b1111111;

 // assign for ADC control signal
assign	AD_SCLK			= 1'b1;			// (DFS)Data Format Select
assign	AD_SDIO			= 1'b1;			// (DCS)Duty Cycle Stabilizer Select
assign	ADA_OE			= 1'b0;				// enable ADA output
assign	ADA_SPI_CS		= 1'b1;				// disable ADA_SPI_CS (CSB)
assign	ADB_OE			= 1'b0;				// enable ADA output
assign	ADB_SPI_CS		= 1'b1;				// disable ADA_SPI_CS (CSB)



// REG/WIRE Declarations for DUalLockin System I/O

wire		[13:0]	adc_data_in;
assign		adc_data_in  =  a2da_data;
wire		[13:0]	dac_out_a_wire;
wire		[13:0]	dac_out_b_wire;
wire 		[11:0]	nco_sync_o; 

wire 		[15:0]	lia_out_x_1;		// lock-in x output signal for lockin_1
wire		[15:0]	lia_out_y_1;		// lock-in y output signal for lockin_1
wire		[15:0]	lia_out_x_2;		// lock-in x output signal for lockin_2
wire		[15:0]	lia_out_y_2;		// lock-in y output signal for lockin_2
wire		[15:0]	lia_out_x_3;		// lock-in x output signal for lockin_2
wire		[15:0]	lia_out_y_3;
wire		[15:0]	lia_out_x_4;		// lock-in x output signal for lockin_2
wire		[15:0]	lia_out_y_4;
wire		[15:0]	lia_out_x_5;		// lock-in x output signal for lockin_2
wire		[15:0]	lia_out_y_5;
wire		[15:0]	lia_out_x_6;		// lock-in x output signal for lockin_2
wire		[15:0]	lia_out_y_6;
wire		[15:0]	lia_out_x_7;		// lock-in x output signal for lockin_2
wire		[15:0]	lia_out_y_7;
wire		[15:0]	lia_out_x_8;		// lock-in x output signal for lockin_2
wire		[15:0]	lia_out_y_8;
wire 		lia_out_valid;

 
 
//--- analog to digital converter capture and sync
	//--- Channel A
always @(negedge reset_n or posedge ADA_DCO)
begin
	if (!reset_n) begin
		per_a2da_d	<= 14'd0;
	end
	else begin
		per_a2da_d	<=  ADA_D;
	end
end

always @(negedge reset_n or posedge sys_clk)  
begin
	if (!reset_n) begin
		a2da_data	<= 14'd0;
	end
	else begin
		a2da_data	<=  per_a2da_d;
	end
end

/*	//--- Channel B
always @(negedge reset_n or posedge ADB_DCO)
begin
	if (!reset_n) begin
		per_a2db_d	<= 14'd0;
	end
	else begin
		per_a2db_d	<=  ADB_D;
	end
end

always @(negedge reset_n or posedge sys_clk)
begin
	if (!reset_n) begin
		a2db_data	<= 14'd0;
	end
	else begin
		a2db_data	<=  per_a2db_d;
	end
end
 
 */
 
// assign for DAC output data
   assign	DA =  dac_out_a;
   assign	DB =  dac_out_b;

		
always @(negedge reset_n or posedge FPGA_CLK_B_P) //DAC output should be run using the DAC clock
begin
	if (!reset_n) begin
		dac_out_a	<= 14'd0;
		dac_out_b   <= 14'd0;
	end
	else begin
		dac_out_a	<= dac_out_a_wire ;
		dac_out_b	<= dac_out_b_wire ;
	end
end

///////////////////////////PROTOCOL To transfer data to a Rasp Pi/////////////////////

eight_lia_pkg_merged eight_lia_pkg_merged_inst(
				.clock_50			(CLOCK_50),
				.fpga_resetn		(reset_n),
				.reg_p_cosines		(dac_out_a_wire),
				.reg_n_cosines		(dac_out_b_wire),
				.lia_out_x_1 		(lia_out_x_1),		// lock-in x output signal for lockin_1
				.lia_out_y_1 		(lia_out_y_1),		// lock-in y output signal for lockin_1
				.lia_out_x_2 		(lia_out_x_2),		// lock-in x output signal for lockin_2
				.lia_out_y_2 		(lia_out_y_2),		// lock-in y output signal for lockin_2
				.lia_out_x_3 		(lia_out_x_3),		// lock-in x output signal for lockin_3
				.lia_out_y_3 		(lia_out_y_3),
				.lia_out_x_4 		(lia_out_x_4),		// lock-in x output signal for lockin_4
				.lia_out_y_4 		(lia_out_y_4),
				.lia_out_x_5 		(lia_out_x_5),		// lock-in x output signal for lockin_5
				.lia_out_y_5 		(lia_out_y_5),
				.lia_out_x_6 		(lia_out_x_6),		// lock-in x output signal for lockin_6
				.lia_out_y_6 		(lia_out_y_6),
				.lia_out_x_7 		(lia_out_x_7),		// lock-in x output signal for lockin_7
				.lia_out_y_7 		(lia_out_y_7),
				.lia_out_x_8 		(lia_out_x_8),		// lock-in x output signal for lockin_8
				.lia_out_y_8 		(lia_out_y_8),
				.lia_out_valid 	(lia_out_valid),				
				.adc_data			(adc_data_in),
				.adc_clk				(ADA_DCO),
				.heartbeat_led		(LEDG[0]),
				.overflow			(CIC_overflow)
				
);

////////////////////////// PLL INSTANTIATION/////////////////////

PLL pll_abc (
	.inclk0(CLOCK_50),
	.c0(FIFO_CLOCK_25));	
	
//////////////////////////////////////////////////////////////////

// single-shot counter
// for CIC out parallel-to-serial
reg l_lia_out_valid;

always @ (posedge CLOCK_50)
begin
l_lia_out_valid <= lia_out_valid;
end

(*noprune*) reg [3:0] cnt = 4'd0;
(*noprune*)reg fifo_load  = 1'b0;  // This variable envelopes 16 system clk cycles for a burst transfer

always @ (posedge FIFO_CLOCK_25)
begin
	if (l_lia_out_valid == 1'b1)
	begin
		cnt <= 4'd0;
		fifo_load <= 1'b1;
	end
	else if (cnt < 4'd15)
	begin
		cnt <= cnt + 1'b1;
	end
	else if (cnt == 4'd15)
	begin
		fifo_load <= 1'b0;
	end
end

(*keep*)wire fifo_write;
(*noprune*)reg [15:0] q_out;

assign fifo_write = fifo_load & ~FIFO_CLOCK_25;
reg l_fifo_write;
reg ll_fifo_write;

always @ (posedge CLOCK_50)
begin
l_fifo_write <= fifo_write;
ll_fifo_write <= l_fifo_write;
end

always @ (posedge fifo_write)
begin
	case (cnt)
		4'd0:  begin	q_out  <= lia_out_x_1; end
		4'd1:  begin	q_out  <= lia_out_y_1; end
		4'd2:  begin	q_out  <= lia_out_x_2; end
		4'd3:  begin	q_out  <= lia_out_y_2; end
		4'd4:  begin	q_out  <= lia_out_x_3; end
		4'd5:  begin	q_out  <= lia_out_y_3; end
		4'd6:  begin	q_out  <= lia_out_x_4; end
		4'd7:  begin	q_out  <= lia_out_y_4; end
		4'd8:  begin	q_out  <= lia_out_x_5; end
		4'd9:  begin	q_out  <= lia_out_y_5; end
		4'd10: begin 	q_out  <= lia_out_x_6; end
		4'd11: begin 	q_out  <= lia_out_y_6; end
		4'd12: begin 	q_out  <= lia_out_x_7; end
		4'd13: begin 	q_out  <= lia_out_y_7; end
		4'd14: begin 	q_out  <= lia_out_x_8; end
		4'd15: begin 	q_out  <= lia_out_y_8; end																																
	endcase
end				

///////////////////////////PROTOCOL//////////////////////////////////////////////////////////

reg [47:0] cic_encoded_data = 48'd0;
reg overflw_reg;
wire overflow;
wire dummy;
(*keep*)wire markXin;
reg markXin_reg;
(*keep*)wire markYin;
reg markYin_reg;
(*noprune*)reg markX_toggle = 1'b0;
(*noprune*)reg markY_toggle = 1'b0;
(*keep*)wire pi_reset_n;
wire CIC_overflow;

assign pi_reset_n = GPIO[17];
assign markXin = GPIO[14];
assign markYin = GPIO[15];
assign LEDR[0] = CIC_overflow;
reg CIC_overflow_LED ;

always @ (negedge fifo_write)
begin
cic_encoded_data <= {CIC_overflow_LED,overflw_reg,markYin_reg,markXin_reg,cnt,q_out[3:0],
							CIC_overflow_LED,overflw_reg,markYin_reg,markXin_reg,cnt,q_out[7:4],
							CIC_overflow_LED,overflw_reg,markYin_reg,markXin_reg,cnt,q_out[11:8],
							CIC_overflow_LED,overflw_reg,markYin_reg,markXin_reg,cnt,q_out[15:12]			//MSB				
							};
end

//pass to FIFO

 FIFO fifo_1 (
	.data(cic_encoded_data),
	.rdclk(GPIO[8]),
	.rdreq(1'b1),
	.wrclk(ll_fifo_write), 
	.wrreq(1'b1),
	.q({dummy,GPIO[10],GPIO[13],GPIO[12],GPIO[7:0]}),   
	.rdempty(GPIO[11]),
	.wrfull(overflow)
	);
	
always @(posedge ll_fifo_write) // NEEDS TO MATCH FIFO WRITE CLK
begin
	overflw_reg <= overflow;
	markXin_reg <= SW[17]? (SW[16]? markX_stretch : markX_toggle) : markXin ;
	markYin_reg <= SW[17]?                          markY_toggle  : markYin ;
	CIC_overflow_LED <= CIC_overflow;
end

always @(negedge pi_reset_n or negedge markXin)  /////using negedge for schmitt trigger to capture data
begin
	if (!pi_reset_n) begin
		markX_toggle	<= 1'd0;
	end
	else begin
		markX_toggle	<=  ~markX_toggle;
	end
end

reg [17:0] markX_stretch_cnt = 18'd0;
reg markX_stretch;

always @ (posedge CLOCK_50)
begin
	if (markXin == 1'b0)
	begin
		markX_stretch_cnt <= 18'd0;
		markX_stretch <= 1'b1;
	end
	else if (markX_stretch_cnt < 18'd100000)
	begin
		markX_stretch_cnt <= markX_stretch_cnt + 1'b1;
	end
	else 
	begin
		markX_stretch <= 1'b0;
	end	

end

always @(negedge pi_reset_n or negedge markYin)  
begin
	if (!pi_reset_n) begin
		markY_toggle	<= 1'd0;
	end
	else begin
		markY_toggle	<=  ~markY_toggle;
	end
end
//////////////////////////////////////////////////////////////////////////////////////////////////////
endmodule
